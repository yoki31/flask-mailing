{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-mailing \u00b6 The flask-mailing simple lightweight mail system, sending emails and attachments(individual && bulk) fully asynchronously. Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for legacy or Flask-Mailman for Django type implementation. Flask-Mailing is a fork of Sabuhi's Fastapi-Mail package, providing similar functionality. 99% of the work was done by him, and the fork was made mainly provide the same features and the apis for the Flask Microframework. A Basic Demo for better understanding \u00b6 from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_TLS' ] = True app . config [ 'MAIL_SSL' ] = False app . config [ 'MAIL_DEFAULT_SENDER' ] = \"your-email@your-domain.com\" mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Using Jinja2 HTML Templates \u00b6 In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2 Guide for Email Utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Writing unittests using Flask-Mailing \u00b6 Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications. Support for Reply-To header is added \u00b6 Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"Flask MAILING"},{"location":"#flask-mailing","text":"The flask-mailing simple lightweight mail system, sending emails and attachments(individual && bulk) fully asynchronously. Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for legacy or Flask-Mailman for Django type implementation. Flask-Mailing is a fork of Sabuhi's Fastapi-Mail package, providing similar functionality. 99% of the work was done by him, and the fork was made mainly provide the same features and the apis for the Flask Microframework.","title":"Flask-mailing"},{"location":"#a-basic-demo-for-better-understanding","text":"from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_TLS' ] = True app . config [ 'MAIL_SSL' ] = False app . config [ 'MAIL_DEFAULT_SENDER' ] = \"your-email@your-domain.com\" mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"A Basic Demo for better understanding"},{"location":"#using-jinja2-html-templates","text":"In order to use Jinja template langauge, your must specify email folder within your applications working directory. In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \" body \" and that it is a python dict. check out jinja2 for more details jinja2","title":"Using Jinja2 HTML Templates"},{"location":"#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for Email Utils"},{"location":"#writing-unittests-using-flask-mailing","text":"Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications.","title":"Writing unittests using Flask-Mailing"},{"location":"#support-for-reply-to-header-is-added","text":"Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.","title":"Support for Reply-To header is added"},{"location":"contribute/","text":"Contributing to flask-mailing \u00b6 We welcome contributions to flask-mailing Issues \u00b6 Feel free to submit issues and enhancement requests. Flask-Mailing Issues Contributing \u00b6 Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contribution"},{"location":"contribute/#contributing-to-flask-mailing","text":"We welcome contributions to flask-mailing","title":"Contributing to flask-mailing"},{"location":"contribute/#issues","text":"Feel free to submit issues and enhancement requests. Flask-Mailing Issues","title":"Issues"},{"location":"contribute/#contributing","text":"Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow. Fork the repo on GitHub Clone the project to your own machine Commit changes to your own branch Push your work Submit a Pull request so that we can review your changes NOTE: Be sure to merge the latest from upstream before making a pull request!","title":"Contributing"},{"location":"example/","text":"Example \u00b6 Sending emails using Falsk-Email \u00b6 List of Examples \u00b6 Basic configuration \u00b6 from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_TLS' ] = True app . config [ 'MAIL_SSL' ] = False mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Send a simple html message \u00b6 html = \"\"\" <p>Hi this test mail, thanks for using Flask-Mailing</p> \"\"\" @app . get ( \"/html-email\" ) async def html_email (): message = Message ( subject = \"Flask-Mailing module test html mail\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = html , subtype = \"html\" ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" }) Sending files \u00b6 @app . get ( \"/mail-file\" ) async def mail_file (): message = Message ( subject = \"attachments based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"email with attachments, email body.\" , attachments = [ 'attachments/attachment.txt' ] ) await mail . send_message ( message ) return jsonify ( message = \"email sent\" ) Using Jinja2 HTML Templates \u00b6 You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in Mail.send_message() . You then can pass a Dict as the template_body property of your Message object. If you haven't provided the TEMPLATE_FOLDER configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder: from pathlib import Path app . config [ \"TEMPLATE_FOLDER\" ] = Path ( __file__ ) . parent / 'email-templates' \"\"\" Don't use this configuration if you want to use the default jinja2 environment. \"\"\" @app . get ( \"/mail-html\" ) async def mail_html (): message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_body = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) await mail . send_message ( message , template_name = \"test.html\" ) return jsonify ( message = \"email sent\" ) For example, assume we pass a template_body of: { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } We can reference the variables in our Jinja templates as per normal: ... < span > Hello, {{ first_name }}! </ span > ... Legacy Behaviour \u00b6 The original behaviour was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also. Guide for email utils \u00b6 The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default. Check dispasoble email address \u00b6 async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send (): domain = \"gmail.com, checker = await default_checker () if await checker . is_dispasoble ( domain ): return jsonify ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return jsonify ( status_code = 200 , content = { 'message' : 'email has been sent' }) Add dispasoble email address \u00b6 @app . get ( '/email/dispasoble' ) async def add_disp_domain (): domains : list = [ \"gmail.com\" ] checker : DefaultChecker = await default_checker () res = await checker . add_temp_domain ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res }) Add domain to blocked list \u00b6 @app . get ( '/email/blocked/domains' ) async def block_domain (): domain : str = \"gmail.com\" checker : DefaultChecker = await default_checker () await checker . blacklist_add_domain ( domain ) return jsonify ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' }) Check domain blocked or not \u00b6 @app . get ( '/email/blocked/check-domains' ) async def get_blocked_domain (): domain : str = 'gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Add email address to blocked list \u00b6 @app . get ( '/email/blocked/address' ) async def block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () await checker . blacklist_add_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : True }) Check email blocked or not \u00b6 @app . get ( '/email/blocked/address' ) async def get_block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_address ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Check MX record \u00b6 @app . get ( \"/email/check-mx\" ) async def check_mx_record (): checker = await default_checker () domain = \"gmail.com\" res = await checker . check_mx_record ( domain , False ) return jsonify ( status_code = 200 , content = { 'result' : res }) Remove email address from blocked list \u00b6 @app . get ( '/email/blocked/address' ) async def del_blocked_address (): checker = await default_checker () email = \"hacker@gmail.com\" res = await checker . blacklist_rm_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Remove domain from blocked list \u00b6 @app . get ( '/email/blocked/domains' ) async def del_blocked_domain (): checker = await default_checker () domain = \"gmail.com\" res = await checker . blacklist_rm_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res }) Remove domain from temporary list \u00b6 @app . get ( '/email/dispasoblee' ) async def del_disp_domain (): checker = await default_checker () domains = [ \"gmail.com\" ] res = await checker . blacklist_rm_temp ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res }) WhoIsXmlApi \u00b6 from flask_mailing.utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not","title":"Example"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#sending-emails-using-falsk-email","text":"","title":"Sending emails using Falsk-Email"},{"location":"example/#list-of-examples","text":"","title":"List of Examples"},{"location":"example/#basic-configuration","text":"from flask import Flask , jsonify from flask_mailing import Mail , Message mail = Mail () def create_app (): app = Flask ( __name__ ) app . config [ 'MAIL_USERNAME' ] = \"your-email@your-domain.com\" app . config [ 'MAIL_PASSWORD' ] = \"world_top_secret_password\" app . config [ 'MAIL_PORT' ] = 587 app . config [ 'MAIL_SERVER' ] = \"your-email-server.com\" app . config [ 'MAIL_TLS' ] = True app . config [ 'MAIL_SSL' ] = False mail . init_app ( app ) return app #send a simple email using flask_mailing module. app = create_app () @app . get ( \"/email\" ) async def simple_send (): message = Message ( subject = \"Flask-Mailing module\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"This is the basic email body\" , ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Basic configuration"},{"location":"example/#send-a-simple-html-message","text":"html = \"\"\" <p>Hi this test mail, thanks for using Flask-Mailing</p> \"\"\" @app . get ( \"/html-email\" ) async def html_email (): message = Message ( subject = \"Flask-Mailing module test html mail\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = html , subtype = \"html\" ) await mail . send_message ( message ) return jsonify ( status_code = 200 , content = { \"message\" : \"email has been sent\" })","title":"Send a simple html message"},{"location":"example/#sending-files","text":"@app . get ( \"/mail-file\" ) async def mail_file (): message = Message ( subject = \"attachments based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], body = \"email with attachments, email body.\" , attachments = [ 'attachments/attachment.txt' ] ) await mail . send_message ( message ) return jsonify ( message = \"email sent\" )","title":"Sending files"},{"location":"example/#using-jinja2-html-templates","text":"You can enable Jinja2 HTML Template emails by setting the TEMPLATE_FOLDER configuration option, and supplying a value (which is just the name of the template file within the TEMPLATE_FOLDER dir) for the template_name parameter in Mail.send_message() . You then can pass a Dict as the template_body property of your Message object. If you haven't provided the TEMPLATE_FOLDER configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder: from pathlib import Path app . config [ \"TEMPLATE_FOLDER\" ] = Path ( __file__ ) . parent / 'email-templates' \"\"\" Don't use this configuration if you want to use the default jinja2 environment. \"\"\" @app . get ( \"/mail-html\" ) async def mail_html (): message = Message ( subject = \"html template based email\" , recipients = [ \"aniketsarkar@yahoo.com\" ], template_body = { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } # attachments = ['attachments/attachment.txt'] ) await mail . send_message ( message , template_name = \"test.html\" ) return jsonify ( message = \"email sent\" ) For example, assume we pass a template_body of: { \"first_name\" : \"Hare\" , \"last_name\" : \"Krishna\" } We can reference the variables in our Jinja templates as per normal: ... < span > Hello, {{ first_name }}! </ span > ...","title":"Using Jinja2 HTML Templates"},{"location":"example/#legacy-behaviour","text":"The original behaviour was to wrap the Dict you provide in a variable named body when it was provided to Jinja behind the scenes. In these versions, you can then access your dict in your template like so: ... <span>Hello, body.first_name !</span> ... As you can see our keys in our dict are no longer the top level, they are part of the body variable. Nesting works as per normal below this level also.","title":"Legacy Behaviour"},{"location":"example/#guide-for-email-utils","text":"The utility allows you to check temporary email addresses, you can block any email or domain. You can connect Redis to save and check email addresses. If you do not provide a Redis configuration, then the utility will save it in the list or set by default.","title":"Guide for email utils"},{"location":"example/#check-dispasoble-email-address","text":"async def default_checker (): checker = DefaultChecker () # you can pass source argument for your own email domains await checker . fetch_temp_email_domains () # require to fetch temporary email domains return checker @app . get ( '/email/dispasoble' ) async def simple_send (): domain = \"gmail.com, checker = await default_checker () if await checker . is_dispasoble ( domain ): return jsonify ( status_code = 400 , content = { 'message' : 'this is dispasoble domain' }) return jsonify ( status_code = 200 , content = { 'message' : 'email has been sent' })","title":"Check dispasoble email address"},{"location":"example/#add-dispasoble-email-address","text":"@app . get ( '/email/dispasoble' ) async def add_disp_domain (): domains : list = [ \"gmail.com\" ] checker : DefaultChecker = await default_checker () res = await checker . add_temp_domain ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Add dispasoble email address"},{"location":"example/#add-domain-to-blocked-list","text":"@app . get ( '/email/blocked/domains' ) async def block_domain (): domain : str = \"gmail.com\" checker : DefaultChecker = await default_checker () await checker . blacklist_add_domain ( domain ) return jsonify ( status_code = 200 , content = { 'message' : f ' { domain } added to blacklist' })","title":"Add domain to blocked list"},{"location":"example/#check-domain-blocked-or-not","text":"@app . get ( '/email/blocked/check-domains' ) async def get_blocked_domain (): domain : str = 'gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Check domain blocked or not"},{"location":"example/#add-email-address-to-blocked-list","text":"@app . get ( '/email/blocked/address' ) async def block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () await checker . blacklist_add_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : True })","title":"Add email address to blocked list"},{"location":"example/#check-email-blocked-or-not","text":"@app . get ( '/email/blocked/address' ) async def get_block_address (): email : str = 'hacker@gmail.com' checker : DefaultChecker = await default_checker () res = await checker . is_blocked_address ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Check email blocked or not"},{"location":"example/#check-mx-record","text":"@app . get ( \"/email/check-mx\" ) async def check_mx_record (): checker = await default_checker () domain = \"gmail.com\" res = await checker . check_mx_record ( domain , False ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Check MX record"},{"location":"example/#remove-email-address-from-blocked-list","text":"@app . get ( '/email/blocked/address' ) async def del_blocked_address (): checker = await default_checker () email = \"hacker@gmail.com\" res = await checker . blacklist_rm_email ( email ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Remove email address from blocked list"},{"location":"example/#remove-domain-from-blocked-list","text":"@app . get ( '/email/blocked/domains' ) async def del_blocked_domain (): checker = await default_checker () domain = \"gmail.com\" res = await checker . blacklist_rm_domain ( domain ) return jsonify ( status_code = 200 , content = { \"result\" : res })","title":"Remove domain from blocked list"},{"location":"example/#remove-domain-from-temporary-list","text":"@app . get ( '/email/dispasoblee' ) async def del_disp_domain (): checker = await default_checker () domains = [ \"gmail.com\" ] res = await checker . blacklist_rm_temp ( domains ) return jsonify ( status_code = 200 , content = { 'result' : res })","title":"Remove domain from temporary list"},{"location":"example/#whoisxmlapi","text":"from flask_mailing.utils import WhoIsXmlApi who_is = WhoIsXmlApi ( token = \"Your access token\" , email = \"your@mailaddress.com\" ) print ( who_is . smtp_check_ ()) #check smtp server print ( who_is . is_dispasoble ()) # check email is disposable or not print ( who_is . check_mx_record ()) # check domain mx records print ( who_is . free_check ) # check email domain is free or not","title":"WhoIsXmlApi"},{"location":"getting-started/","text":"\ud83d\udd79 Guide \u00b6 After installing the module and setting up your Flask app: Main classes and packages are Mail Message utils.DefaultChecker utils.WhoIsXmlApi Available config options \u00b6 class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_USE_TLS : For TLS connection MAIL_USE_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_DEFAULT_SENDER : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER : If you are using jinja2, specify template folder name SUPPRESS_SEND : To mock sending out mail, defaults 0. USE_CREDENTIALS : Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS : Defaults to True . It enables to choose whether to verify the mail server's certificate Mail class \u00b6 class has following attributes and methods send_message : The methods has two atributes, message: Message, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML. Message class \u00b6 class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain utils.DefaultChecker class \u00b6 Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis utils.WhoIsXmlApi class \u00b6 WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"\ud83d\udd79 Getting Started"},{"location":"getting-started/#guide","text":"After installing the module and setting up your Flask app: Main classes and packages are Mail Message utils.DefaultChecker utils.WhoIsXmlApi","title":"\ud83d\udd79 Guide"},{"location":"getting-started/#available-config-options","text":"class has following attributes MAIL_USERNAME : Username for email, some email hosts separates username from the default sender(AWS). If you service does not provide username use sender address for connection. MAIL_PASSWORD : Password for authentication MAIL_SERVER : SMTP Mail server. MAIL_USE_TLS : For TLS connection MAIL_USE_SSL : For TLS connection MAIL_DEBUG : Debug mode for while sending mails, defaults 0. MAIL_FROM : Sender address MAIL_DEFAULT_SENDER : Sender address MAIL_FROM_NAME : Title for Mail TEMPLATE_FOLDER : If you are using jinja2, specify template folder name SUPPRESS_SEND : To mock sending out mail, defaults 0. USE_CREDENTIALS : Defaults to True . However it enables users to choose whether or not to login to their SMTP server. VALIDATE_CERTS : Defaults to True . It enables to choose whether to verify the mail server's certificate","title":"Available config options"},{"location":"getting-started/#mail-class","text":"class has following attributes and methods send_message : The methods has two atributes, message: Message, template_name=None message : where you define message sturcture for email template_name : if you are using jinja2 consider template_name as well for passing HTML.","title":"Mail class"},{"location":"getting-started/#message-class","text":"class has following attributes recipients : List of recipients. attachments : attachments within mail subject : subject content of the mail body : body of the message cc : cc recipients of the mail bcc : bcc recipients of the mail reply_to : Reply-To recipients in the mail charset : charset defaults to utf-8 subtype : subtype of the mail defaults to plain","title":"Message class"},{"location":"getting-started/#utilsdefaultchecker-class","text":"Default class for checking email from collected public resource. The class makes it possible to use redis to save data. source : optional source for collected email data. db_provider : switch to redis","title":"utils.DefaultChecker class"},{"location":"getting-started/#utilswhoisxmlapi-class","text":"WhoIsXmlApi class provide working with api WhoIsXmlApi This service gives free 1000 request to checking email address per month. token : token you can get from this WhoIsXmlApi link email : email for checking","title":"utils.WhoIsXmlApi class"},{"location":"install/","text":"Using pip \u00b6 python3 -m venv .venv source .venv/bin/activate pip install flask-mailing Using source code \u00b6 git clone https://github.com/marktennyson/flask-mailing && cd flask-mailing python3 setup.py install","title":"\ud83d\udd28 Installation"},{"location":"install/#using-pip","text":"python3 -m venv .venv source .venv/bin/activate pip install flask-mailing","title":"Using pip"},{"location":"install/#using-source-code","text":"git clone https://github.com/marktennyson/flask-mailing && cd flask-mailing python3 setup.py install","title":"Using source code"}]}